<!DOCTYPE html>
<meta charset="utf-8">
<script src="http://d3js.org/d3.v2.min.js?2.9.3"></script>
<script src="https://d3js.org/d3-collection.v1.min.js"></script>
<script src="https://d3js.org/d3-array.v1.min.js"></script>
<script src="http://chancejs.com/chance.min.js"></script>
<script src="https://d3js.org/d3-timer.v1.min.js"></script>
<script src="http://localhost:35729/livereload.js"></script>
<script src="graph.js"></script>
<script src="display_utils.js"></script>
<script src="guys.js"></script>
<script src="shortest_path.js"></script>
<script src="shortcuts.js"></script>
<script src="keyhandlers.js"></script>
<style>

circle {
	stroke: none;
}

circle.guy {
	fill: #f0f;
	transform: scale(2);
}

circle.exit {
	fill: #0f0;
	transform: scale(1);
}
line {
	stroke: black;
}
</style>
<body>
<svg width="800" height="600" ></svg>
<script>
// var node_colors = {empty: "#000", exit: "#0f0", guy: "#f0f", seed: "#ff0", soft_obstacle: "#0ff", highlighted: "#f00"};

var lastSelected = null;

load_graph('simple_test.json', function(nodes, grid_width, grid_height, radius) {
// global constants
var svg = d3.select("svg")

// TODO: write higher level point framework
svg.selectAll("g")  
	.data(nodes, function(d) { return d.id; }) // to track deletions, we need a good key.
      .enter()
      .append("g")
      .attr("transform", function(d) { return "translate(" + d.cx + ", " + d.cy + ")" }) 
/*
I'm trying to do the state updating. The problem is that it is not entirely local, we need to see if a space is occupied.
so there is global state.
*/

svg.selectAll("g")
     .append("text")
     .attr("dx", 12)
     .attr("dy", "1em")
	.text(function(d) { return d.id + ' - ' + d.distance; })


svg.selectAll("g")
      .append("circle")
      .attr("r", 10)
      .attr("class", function(d) { return d.node_type; })

});

var simulation_history = [];
d3.select(window).on('keydown', function() {
	d3.event.preventDefault();
	
	//console.log(d3.event.keyCode)

	if (d3.event.keyCode == 39) { // right arrow 
		if (has_guys_away_from_exit()) {
			simulation_history.push(move_guys_to_exit());
		}

	}
	if (d3.event.keyCode == 37) { // left arrow 

		if (simulation_history.length > 0) {
			var types = simulation_history.pop();

			d3.selectAll("g").each((d, i) => d.node_type = types[i]);
			d3.selectAll("g circle").attr('class', d => d.node_type);
		}
	}
	if (d3.event.keyCode == 69) { // 'e' is the delete key
		console.log(lastSelected)

		if (lastSelected) {
			delete_node(lastSelected)
		}			
	}
})
d3.selectAll('circle').on('click', function(d) { 
	var new_type = d.node_type == 'empty' ? 'guy' : 'empty';
	d.node_type = new_type; 
	d3.select(this).attr('class', new_type);	

	lastSelected = d3.select(this);
})


</script>
</body>
